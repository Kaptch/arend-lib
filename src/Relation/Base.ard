\import Function
\import Logic
\import Paths

-- Попытка №1

\module EX1 \where {
  \class HomogeneousRelation {
    | Carrier : \Set
    | \infix 7 ~~> : Carrier -> Carrier -> \Prop
  }

  \func eval {A : \Set} : HomogeneousRelation A -> A -> A -> \Prop =>
    \lam (r : HomogeneousRelation A) =>
        \lam (x y : A) => x r.~~> y

  \func isReflexive {A : \Set} (rel : HomogeneousRelation A) : \Prop =>
    \Pi (x : A) -> x ~~> x

  \func isSymmetric {A : \Set} (rel : HomogeneousRelation A) : \Prop =>
    \Pi (x y : A) -> x ~~> y -> y ~~> x

  \func isTransitive {A : \Set} (rel : HomogeneousRelation A) : \Prop =>
    \Pi (x y z : A) -> x ~~> y -> y ~~> z -> x ~~> z

  \func isDecidable {A B : \Set} (rel : HomogeneousRelation A) : \Prop =>
    \Pi (x y : A) -> (x ~~> y) || (Not (x ~~> y))

  \func preserves {A : \Set} (rel : HomogeneousRelation A) (f : A -> A)
    : \Prop =>
    \Pi (x y : A) -> x ~~> y -> (f x) ~~> y

  \func isImplication {A : \Set} (rel1 : HomogeneousRelation A)
                      (rel2 : HomogeneousRelation A) : \Prop =>
    \Pi (x y : A) -> x rel1.~~> y -> x rel2.~~> y

  \func \infix 6 ==> => isImplication

  \func flip {A : \Set} (rel : HomogeneousRelation A)
    : HomogeneousRelation A =>
    \new HomogeneousRelation A {
      | ~~> => \lam x y => flip' (~~>) x y
    }
    \where
      \func flip' {A : \Set} : (A -> A -> \Prop) -> (A -> A -> \Prop) =>
        \lam (r : A -> A -> \Prop) =>
            \lam x y => r y x

  \func composition {A : \Set} (rel1 : HomogeneousRelation A)
                    (rel2 : HomogeneousRelation A)
    : HomogeneousRelation A =>
    \new HomogeneousRelation A {
      | ~~> => \lam (x z : A) =>
          TruncP (\Sigma (y : A) (Not (x rel1.~~> y) || Not (y rel2.~~> z)))
    }

  \func \infix 6 <> {A : \Set} (rel1 : HomogeneousRelation A)
                    (rel2 : HomogeneousRelation A) : HomogeneousRelation A =>
    composition rel1 rel2

  \func idRelation (A : \Set) : HomogeneousRelation A =>
    \new HomogeneousRelation A {
      | ~~> => \lam (x y : A) => x = y
    }

  \func union {A : \Set} (rel1 : HomogeneousRelation A)
              (rel2 : HomogeneousRelation A) : HomogeneousRelation A =>
    \new HomogeneousRelation A {
      | ~~> => \lam (x y : A) => x rel1.~~> y || x rel2.~~> y
    }

  \func \infix 5 >< {A : \Set} (rel1 : HomogeneousRelation A)
                    (rel2 : HomogeneousRelation A)
    : HomogeneousRelation A =>
    union rel1 rel2

  -- Полная форма любого замыкания может быть представлена как: (замыкание,
  -- доказательство требуемого свойства для замыкания,
  -- доказательство минимальности)
  -- Например
  -- \func REFLCLOSURE {A : \Set}
  --                   (rel : HomogeneousRelation A)
  --   : \Sigma (r : HomogeneousRelation A)
  --            (isReflexive r)
  --            (\Pi (a : HomogeneousRelation A) (isRelexive a -> r ==> a))

  \func reflexiveClosure {A : \Set}
                         (rel : HomogeneousRelation A)
    : HomogeneousRelation A =>
    rel >< (idRelation A)

  \func reflexiveClosureIsReflexive {A : \Set}
                                    (rel : HomogeneousRelation A)
    : isReflexive (reflexiveClosure rel) =>
    \lam (x : A) => byRight idp

  \func symmetricClosure (rel : HomogeneousRelation) : HomogeneousRelation =>
    rel >< (flip rel)

  \func symmetricClosureIsSymmetric {A : \Set}
                                    (rel : HomogeneousRelation A)
    : isSymmetric (symmetricClosure rel) =>
    \lam (x y : A) => ||.rec (Path.inProp {y ~~> x || x ~~> y})
                             byRight
                             byLeft

  -- | TODO
  \func transitiveClosure {A : \Set} (rel : HomogeneousRelation A)
    : HomogeneousRelation A =>
    \new HomogeneousRelation A {
      | ~~> => {?}
    }

  \func transitiveClosureIsTransitive {A : \Set}
                                      (rel : HomogeneousRelation A)
    : isTransitive (transitiveClosure rel) => {?}

  \func transitiveReflexiveClosure {A : \Set} (rel : HomogeneousRelation A)
    : HomogeneousRelation A =>
    \new HomogeneousRelation A {
      | ~~> => {?}
    }

  \func transitiveReflexiveClosureIsTransitive {A : \Set}
                                               (rel : HomogeneousRelation A)
    : isTransitive (transitiveClosure rel) => {?}

  \func transitiveReflexiveClosureIsReflexive {A : \Set}
                                              (rel : HomogeneousRelation A)
    : isTransitive (transitiveClosure rel) => {?}

  \func transitiveSymmetricReflexiveClosure {A : \Set} (rel : HomogeneousRelation A)
    : HomogeneousRelation A =>
    \new HomogeneousRelation A {
      | ~~> => {?}
    }

  --- Klop definitions

  \func isNormalForm {A : \Set} (rule : HomogeneousRelation A)
    : A -> \Prop => \lam (x : A) =>
      Not (\Sigma (y : A) (x ~~> y))

  \func hasNormalForm {A : \Set} (rule : HomogeneousRelation A)
    : A -> \Prop => \lam (y : A) =>
      TruncP (\Sigma (x : A) (isNormalForm rule x) (eval (transitiveReflexiveClosure rule) y x))

  \func normalForm {A : \Set} (rule : HomogeneousRelation A)
    : A -> \Prop => \lam (x : A) => {?}
}

-- Попытка #2

\module EX2 \where {
  \func REL (A : \Set) : \Type => A -> A -> \Prop

  -- Свойства бинарных отношений

  \func isRefl {A : \Set} (r : REL A) : \Prop =>
    \Pi (x : A) -> r x x

  \func isSymm {A : \Set} (r : REL A) : \Prop =>
    \Pi (x y : A) -> r x y -> r y x

  \func isTrans {A : \Set} (r : REL A) : \Prop =>
    \Pi (x y z : A) -> r x y -> r y z -> r x z

  \func flip {A : \Set} (r : REL A) : REL A =>
    \lam (x y : A) => r y x

  -- Вложение

  \func implies {A : \Set} (r : REL A) (p : REL A) : \Prop =>
    \Pi (x y : A) -> r x y -> p x y

  -- Объединение

  \func union {A : \Set} (rel1 : REL A)
              (rel2 : REL A) : REL A =>
    \lam (x y : A) => rel1 x y || rel2 x y

  \func idREL {A : \Set} : REL A => \lam (x y : A) => x = y

  -- Тип замыкания отношения

  \func closure {A : \Set}
                (initRel : REL A)
                (prop : REL A -> \Prop)
                (build : REL A -> REL A) : \Type =>
    \Sigma (newRel : REL A) -- Само замыкание
           (prop newRel) -- Доказательство того, что замыкание удовлетворяет свойству
           (p : newRel = build initRel) -- Доказательство того, что замыкание построено с помощью build (наверное, можно заменить newRel на build rel и избавиться от этого поля)
           (\Pi (p : REL A) -> -- Доказательство того, что для любого расширения исходного отношения, обладающего требуемым св-ом, newRel лежит в этом расширении
               implies initRel p ->
               prop p ->
               implies newRel p)

  -- Рефлексивное замыкание

  \func reflClosure {A : \Set} (rel : REL A)
    : closure rel isRefl _buildReflClosure =>
    (_buildReflClosure rel,
     \lam _ => byRight idp,
     idp,
     \lam (p : REL A) =>
         \lam (o : implies rel p) =>
             \lam (proof : isRefl p) =>
                 \lam x y =>
                     \lam q => \case q \with {
                       | byLeft (t1 : rel x y) => o x y t1
                       | byRight (t2 : x = y) => coe2 (@ (pmap2 p idp t2))
                                                      left
                                                      (proof x)
                                                      right
                     })
    \where
      \func _buildReflClosure {A : \Set} (r : REL A) : REL A => union r idREL

  -- Симметричное замыкание

  \func symmClosure {A : \Set} (rel : REL A)
    : closure rel isSymm _buildSymmClosure =>
    (_buildSymmClosure rel,
     \lam (x y : A) => ||.rec Path.inProp
                              byRight
                              byLeft,
     idp,
     \lam (p : REL A) =>
         \lam (o : implies rel p) =>
             \lam (proof : isSymm p) =>
                 \lam x y =>
                     \lam q => \case q \with {
                       | byLeft (t1 : rel x y) => o x y t1
                       | byRight (t2 : rel y x) => proof y x (o y x t2)
                     })
    \where
      \func _buildSymmClosure {A : \Set} (r : REL A) : REL A =>
        union r (flip r)

  -- Lemma 10.3.2 smh is proved by Arend (accessibility is a mere property)

  \data acc {A : \Set} (rel : REL A) (a : A) : \Prop
    | accREL (f : \Pi (b : A) -> (rel b a) -> acc rel b)
    \where
      \func ind {A : \Set} (rel : REL A) (a : A)
                (P : \Pi (a : A) -> (acc rel a -> \Type))
                (f : \Pi (a : A) ->
                    \Pi (h : \Pi (b : A) -> (rel b a) -> acc rel b) ->
                        (\Pi (b : A) -> \Pi (l : rel b a) -> P b (h b l)) ->
                        P a (accREL h : acc rel a))
                (b : A)
                (c : acc rel b)
        : P b c
        | rel', _, P', f', b', (accREL h') =>
          f' b' h' (\lam b => \lam l => ind rel' b' P' f' b (h' b l))

  \func wellFounded {A : \Set} (rel : REL A) : \Prop =>
    \Pi (x : A) -> acc rel x

  -- Тип для индуктивного определения транзитивного замыкания

  \truncated \data TransClosure {A : \Set} (rel : REL A) (a b : A) : \Prop
    | base (r : rel a b)
    | trans (x : A) (t : (TransClosure rel) a x) (r : (TransClosure rel) x b)
    \where
      \func downwardsClosed {A : \Set}
                            (rel : REL A)
                            (x y : A)
                            (a : acc (TransClosure rel) y)
                            (t : TransClosure rel x y)
        : acc (TransClosure rel) x
        | rel, x, y, (accREL h), r =>
          accREL (\lam z =>
              \lam t =>
                  accREL (\lam b =>
                      \lam (p : TransClosure rel b z) =>
                          h b (trans x (trans z p t) r)))

  \func transClosure {A : \Set} (rel : REL A)
    : closure rel isTrans _buildTransClosure =>
    (_buildTransClosure rel,
     \lam x y z => \lam r => \lam q => trans y r q,
     idp,
     \lam (p : REL A) =>
         \lam (i1 : implies rel p) =>
             \lam (transPr : isTrans p) =>
                 \lam (x y : A) =>
                     \lam (t : TransClosure rel x y) =>
                         _implies rel p i1 transPr x y t)
    \where {
      \func _buildTransClosure {A : \Set} (r : REL A) : REL A => TransClosure r

      \func _implies {A : \Set}
                     (rel : REL A)
                     (p : REL A)
                     (i1 : implies rel p)
                     (transPr : isTrans p)
                     (x y : A)
                     (t : TransClosure rel x y) : p x y
        | rel, p, i1, transPr, x, y, base r => i1 x y r
        | rel, p, i1, transPr, x, y, trans x1 t1 r1 =>
          transPr x x1 y
                  (_implies rel p i1 transPr x x1 t1)
                  (_implies rel p i1 transPr x1 y r1)
    }

  \func transReflClosure {A : \Set} (rel : REL A)
    : closure rel
              (\lam (r : REL A) => (isTrans r && isRefl r))
              _buildTransReflClosure =>
    (_buildTransReflClosure rel,
     prod (_isTrans rel) (_isRefl rel),
     idp,
     \lam (p : REL A) =>
         \lam (i1 : implies rel p) =>
             \lam (pr : isTrans p && isRefl p) => _implies rel p i1 pr)
    \where {
      \func _buildTransReflClosure {A : \Set} (r : REL A) : REL A =>
        (reflClosure (TransClosure r)).1

      \func _isTrans {A : \Set} (r : REL A) (x y z : A)
                     (p : TransClosure r x y || (x = y))
                     (t : TransClosure r y z || (y = z))
        : TransClosure r x z || (x = z)
        | r, a, b, c, byRight b1, byRight b2 => byRight
            (b1 *> b2)
        | r, a, b, c, byLeft b1, byRight b2 => byLeft
            (transport (\lam v => TransClosure r a v) b2 b1)
        | r, a, b, c, byRight b1, byLeft b2 => byLeft
            (transport (\lam v => TransClosure r v c) (inv b1) b2)
        | r, a, b, c, byLeft b1, byLeft b2 => byLeft
            (trans b b1 b2)

      \func _isRefl {A : \Set} (r : REL A)
        : \Pi (x : A) -> (_buildTransReflClosure r) x x =>
        \lam (a : A) => byRight idp

      \func _implies {A : \Set}
                     (rel : REL A)
                     (p : REL A)
                     (i1 : implies rel p)
                     (pr : isTrans p && isRefl p)
                     (x y : A)
                     (t : (reflClosure (TransClosure rel)).1 x y) : p x y
        | rel, p, i1, prod a b, x, y, byLeft a1 => \case a1 \with {
          | base r' => i1 x y r'
          | trans x' t' r' => a x x' y
                                (transClosure._implies rel p i1 a x x' t')
                                (transClosure._implies rel p i1 a x' y r')
        }
        | rel, p, i1, prod a b, x, y, byRight b1 => coe2
            (@ (pmap2 p idp b1))
            left
            (b x)
            right
    }

  \func stronglyNormalizing {A : \Set} (rule : REL A) : \Prop =>
    wellFounded rule

  \func isNormalForm {A : \Set} (rule : REL A)
    : A -> \Prop => \lam (x : A) => Not (\Sigma (y : A) (rule x y))

  \func hasNormalForm {A : \Set} (rule : REL A) : A -> \Prop =>
    \lam (x : A) =>
        \let | rule* : REL A => (transReflClosure rule).1
        \in TruncP (\Sigma (y : A) (rule* x y) (isNormalForm rule y))

  \func weaklyNormalizing {A : \Set} (rule : REL A) : \Prop =>
    \Pi (x : A) -> hasNormalForm rule x

  \func weaklyConfluent {A : \Set} (rule : REL A) : A -> \Prop =>
    \let | rule* : REL A => (transReflClosure rule).1
    \in \lam (x : A) =>
        TruncP (\Pi (y z : A) ->
            \Sigma (rule x y) (rule x z) ->
            \Sigma (t : A) (rule* y t) (rule* z t))

  \func confluent {A : \Set} (rule : REL A) : A -> \Prop =>
    \let | rule* : REL A => (transReflClosure rule).1
    \in \lam (x : A) =>
        TruncP (\Pi (y z : A) ->
            \Sigma (rule x y) (rule x z) ->
            \Sigma (t : A) (rule* y t) ((rule z t || (z = t))))
}