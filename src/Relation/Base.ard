\import Function
\import Logic
\import Paths
\import Data.Sigma

\module Relation \where {
  \module Base \where {
    \func relation (A : \Set)
      : \Type =>
      A -> A -> \Prop

    \func reflexive {A : \Set}
                    (r : relation A)
      : \Prop =>
      \Pi (x : A) -> r x x

    \func symmetric {A : \Set}
                    (r : relation A)
      : \Prop =>
      \Pi (x y : A) -> r x y -> r y x

    \func transitive {A : \Set}
                     (r : relation A)
      : \Prop =>
      \Pi (x y z : A) -> r x y -> r y z -> r x z

    \func antisymmetric {A : \Set}
                        (r : relation A)
      : \Prop =>
      \Pi (x y : A) -> r x y -> r y x -> x = y

    \func equivalence {A : \Set}
                      (r : relation A)
      : \Prop =>
      \Sigma (reflexive r)
             (symmetric r)
             (transitive r)

    \func inverse {A : \Set}
                  (r : relation A)
      : relation A =>
      \lam (x y : A) => r y x

    \data co-relation {A : \Set}
                      (rel : relation A) (a b : A)
      | op (rel b a)

    \func inclusion {A : \Set}
                    (r : relation A)
                    (p : relation A)
      : \Prop =>
      \Pi (x y : A) -> r x y -> p x y

    \func equals {A : \Set}
                 (r : relation A)
                 (p : relation A)
      : \Prop =>
      \Sigma (inclusion r p)
             (inclusion p r)

    \func commutes {A : \Set}
                   (r : relation A)
                   (p : relation A)
      : \Prop =>
      \Pi (x y : A) ->
          r y x ->
          \Pi (z : A) (p z y) ->
              TruncP (\Sigma (a : A)
                             (p a x)
                             (r z a))

    \func union {A : \Set}
                (rel1 : relation A)
                (rel2 : relation A)
      : relation A =>
      \lam (x y : A) => rel1 x y || rel2 x y

    \func closure {A : \Set}
                  (initial : relation A)
                  (property : relation A -> \Prop)
                  (constructor : relation A -> relation A)
      : \Type =>
      \Sigma (new : relation A)
             (property new)
             (p : new = constructor initial)
             (\Pi (p : relation A) ->
                 inclusion initial p ->
                 property p ->
                 inclusion new p)
  }

  \module ReflexiveClosure \where {
    \open Base

    \func reflexiveClosure {A : \Set}
                           (rel : relation A)
      : closure rel reflexive constructor =>
      (constructor rel,
       _reflexive rel,
       idp,
       _inclusion rel)
      \where {
        \func constructor {A : \Set}
                          (r : relation A)
          : relation A =>
          union r (=)

        \func _reflexive {A : \Set}
                         (r : relation A)
          : reflexive (constructor r) =>
          \lam _ => byRight idp

        \func _inclusion {A : \Set}
                         (rel : relation A)
                         (p : relation A)
                         (i1 : inclusion rel p)
                         (pr : reflexive p)
          : inclusion (constructor rel) p
          | rel, p, i1, pr =>
            \lam x y =>
                \lam u =>
                    \case u \with {
                      | byLeft a => i1 x y a
                      | byRight b => coe2 (@ (pmap2 p idp b))
                                          left
                                          (pr x)
                                          right
                    }
      }
  }

  -- TODO: rewrite with inductive definition

  \module SymmetricClosure \where {
    \open Base

    \func symmetricClosure {A : \Set}
                           (rel : relation A)
      : closure rel symmetric constructor =>
      (constructor rel,
       _symmetric rel,
       idp,
       _inclusion rel)
      \where {
        \func constructor {A : \Set}
                          (r : relation A)
          : relation A =>
          union r (inverse r)

        \func _symmetric {A : \Set}
                         (r : relation A)
          : symmetric (constructor r) =>
          \lam (x y : A) => ||.rec Path.inProp
                                   byRight
                                   byLeft

        \func _inclusion {A : \Set}
                         (rel : relation A)
                         (p : relation A)
                         (i1 : inclusion rel p)
                         (pr : symmetric p)
          : inclusion (constructor rel) p
          | rel, p, i1, pr =>
            \lam x y =>
                \lam q =>
                    \case q \with {
                      | byLeft (t1 : rel x y) => i1 x y t1
                      | byRight (t2 : rel y x) => pr y x (i1 y x t2)
                    }
      }
  }

  \module TransitiveClosure \where {
    \open Base

    \truncated \data TC {A : \Set}
                        (rel : relation A)
                        (a b : A)
    : \Prop
      | base (r : rel a b)
      | cons (x : A) (t : rel a x) (r : (TC rel) x b)

    \func concat {A : \Set}
                 (rel : relation A)
                 (a b c : A)
                 (r1 : TC rel a b)
                 (r2 : TC rel b c)
      : TC rel a c
      | rel, a, b, c, base r1, base r2 =>
        cons b r1 (base r2)
      | rel, a, b, c, base r1, cons x2 t2 r2 =>
        cons b r1 (cons x2 t2 r2)
      | rel, a, b, c, cons x1 t1 r1, base r2 =>
        cons x1 t1 (concat rel x1 b c r1 (base r2))
      | rel, a, b, c, cons x1 t1 r1, cons x2 t2 r2 =>
        cons x1 t1  (concat rel x1 b c r1 (cons x2 t2 r2))

    \func transitiveClosure {A : \Set}
                            (rel : relation A)
      : closure rel transitive constructor =>
      (constructor rel,
       _transitive rel,
       idp,
       _inclusion rel)
      \where {
        \func constructor {A : \Set}
                          (r : relation A)
          : relation A =>
          TC r

        \func _transitive {A : \Set}
                          (rel : relation A)
          : transitive (constructor rel) =>
          \lam x y z =>
              \lam r =>
                  \lam q =>
                      concat rel x y z r q

        \func _inclusion {A : \Set}
                         (rel : relation A)
                         (p : relation A)
                         (i1 : inclusion rel p)
                         (transPr : transitive p)
                         (x y : A)
                         (t : TC rel x y)
          : p x y
          | rel, p, i1, transPr, x, y, base r1 =>
            i1 x y r1
          | rel, p, i1, transPr, x, y, cons x1 t1 r1 =>
            transPr x x1 y (i1 x x1 t1) (_inclusion rel p i1 transPr x1 y r1)
      }
  }

  \module ReflexiveTransitiveClosure \where {
    \open Base

    \truncated \data RTC {A : \Set}
                         (rel : relation A)
                         (a b : A)
    : \Prop
      | base (r : a = b)
      | cons (x : A)  (t : rel a x) (r : (RTC rel) x b)

    \func reflexiveTransitiveClosure {A : \Set}
                                     (rel : relation A)
      : closure rel
                (\lam (r : relation A) => \Sigma (transitive r) (reflexive r))
                constructor =>
      (constructor rel,
       (_transitive rel, _reflexive rel),
       idp,
       _inclusion rel)
      \where {
        \func constructor {A : \Set}
                          (r : relation A)
          : relation A =>
          RTC r

        \func _transitive {A : \Set} (r : relation A) (x y z : A)
                          (p : RTC r x y)
                          (t : RTC r y z)
          : RTC r x z
          | r, x, y, z, base r1, base r2 =>
            base (r1 *> r2)
          | r, x, y, z, base r1, cons x1 t r2 =>
            transport (\lam v => RTC r v z) (inv r1) (cons x1 t r2)
          | r, x, y, z, cons x1 t r1, base r2 =>
            cons x1 t (transport (\lam v => RTC r x1 v) r2 r1)
          | r, x, y, z, cons x1 t r1, cons x2 t1 r2 =>
            concat r x y z (cons x1 t r1) (cons x2 t1 r2)

        \func _reflexive {A : \Set}
                         (r : relation A)
          : \Pi (x : A) -> (RTC r) x x =>
          \lam (a : A) => base idp

        \func _inclusion {A : \Set}
                         (rel : relation A)
                         (p : relation A)
                         (i1 : inclusion rel p)
                         (pr : \Sigma (transitive p) (reflexive p))
                         (x y : A)
                         (t : (constructor rel x y)) : p x y
          | rel, p, i1, pr, x, y, base r => coe2
              (@ (pmap2 p idp r))
              left
              (pr.2 x)
              right
          | rel, p, i1, pr, x, y, cons x1 t r => pr.1 x x1 y (i1 x x1 t) (_inclusion rel p i1 pr x1 y r)
      }

    \func concat {A : \Set}
                 (rel : relation A)
                 (a b c : A)
                 (r1 : RTC rel a b)
                 (r2 : RTC rel b c)
      : RTC rel a c
      | rel, a, b, c, base r1, base r2 =>
        base (r1 *> r2)
      | rel, a, b, c, base r1, r2 =>
        transport (\lam v => RTC rel v c) (inv r1) r2
      | rel, a, b, c, cons x1 t1 r1, base r2 =>
        cons x1 t1 (concat rel x1 b c r1 (base r2))
      | rel, a, b, c, cons x1 t1 r1, cons x2 t2 r2 =>
        cons x1 t1  (concat rel x1 b c r1 (cons x2 t2 r2))
  }

  \module ReflexiveSymmetricTransitiveClosure \where {
    \open Base

    \truncated \data RSTC {A : \Set}
                          (rel : relation A)
                          (a b : A)
    : \Prop
      | step (r : rel a b)
      | refl (p : a = b)
      | flip (t : RSTC rel b a)
      | cons (x : A) (t : (RSTC rel) a x) (r : (RSTC rel) x b)

    \func reflexiveSymmetricTransitiveClosure {A : \Set}
                                              (rel : relation A)
      : closure rel
                (\lam (r : relation A) => \Sigma (transitive r) (reflexive r) (symmetric r))
                constructor =>
      (constructor rel,
       (_transitive rel, _reflexive rel, _symmetric rel),
       idp,
       _inclusion rel)
      \where {
        \func constructor {A : \Set}
                          (r : relation A)
          : relation A =>
          RSTC r

        \func _transitive {A : \Set}
                          (r : relation A)
                          (x y z : A)
                          (p1 : constructor r x y)
                          (p2 : constructor r y z)
          : constructor r x z => cons y p1 p2

        \func _reflexive {A : \Set} (r : relation A)
          : \Pi (x : A) ->
            (constructor r) x x =>
          \lam (x : A) => refl idp

        \func _symmetric {A : \Set} (r : relation A)
          : \Pi (x y : A) ->
            (constructor r) x y ->
            (constructor r) y x =>
          \lam (x y : A) =>
              \lam (p : RSTC r x y) => flip p

        \func _inclusion {A : \Set}
                         (rel : relation A)
                         (p : relation A)
                         (i1 : inclusion rel p)
                         (pr : \Sigma (transitive p) (reflexive p) (symmetric p))
                         (x y : A)
                         (t : (constructor rel) x y)
          : p x y
          | rel, p, i1, pr, x, y, step r => i1 x y r
          | rel, p, i1, pr, x, y, refl p1 => coe2
              (@ (pmap2 p idp p1))
              left
              (pr.2 x)
              right
          | rel, p, i1, pr, x, y, flip t => pr.3 y x (_inclusion rel p i1 pr y x t)
          | rel, p, i1, pr, x, y, cons x1 t r => pr.1 x x1 y (_inclusion rel p i1 pr x x1 t) (_inclusion rel p i1 pr x1 y r)
      }

    \func concat {A : \Set}
                 (rel : relation A)
                 (a b c : A)
                 (r1 : RSTC rel a b)
                 (r2 : RSTC rel b c)
      : RSTC rel a c => cons b r1 r2
  }

  \module Utils \where {
    \open Base

    \func plusToStar {A : \Set}
                     (rel : relation A)
                     (a b : A)
                     (r : TransitiveClosure.TC rel a b)
      : ReflexiveTransitiveClosure.RTC rel a b
      | rel, a, b, TransitiveClosure.TC.base r =>
        ReflexiveTransitiveClosure.RTC.cons b r (ReflexiveTransitiveClosure.RTC.base idp : ReflexiveTransitiveClosure.RTC rel b b)
      | rel, a, b, TransitiveClosure.TC.cons x t r =>
        ReflexiveTransitiveClosure.RTC.cons x t (plusToStar rel x b r)

    \func starToPlus {A : \Set}
                     (rel : relation A)
                     (a b c : A)
                     (p : rel a b)
                     (r : ReflexiveTransitiveClosure.RTC rel b c)
      : TransitiveClosure.TC rel a c
      | rel, a, b, c, p, ReflexiveTransitiveClosure.RTC.base r =>
        transport (\lam v => TransitiveClosure.TC rel a v) r (TransitiveClosure.TC.base p)
      | rel, a, b, c, p, ReflexiveTransitiveClosure.RTC.cons x t r =>
        TransitiveClosure.TC.cons b p (starToPlus rel b x c t r)
  }

  \module Wellfounded \where {
    \open Base

    \data acc {A : \Set}
              (rel : relation A)
              (a : A)
    : \Type
      | accREL (f : \Pi (b : A) -> rel b a -> acc rel b)
      \where
        \func ind {A : \Set}
                  {rel : relation A}
                  (P : \Pi (a : A) -> acc rel a -> \Type)
                  (f : \Pi (a : A) ->
                      \Pi (h : \Pi (b : A) -> (rel b a) -> acc rel b) ->
                          (\Pi (b : A) -> \Pi (l : rel b a) -> P b (h b l)) ->
                          P a (accREL h))
                  (a : A)
                  (c : acc rel a)
          : P a c
          |  P, f, a, (accREL h) =>
            f a h (\lam b => \lam l => ind P f b (h b l))

    \func isProp (A : \Set)
                 (rel : relation A)
                 (a : A)
                 (s1 s2 : acc rel a)
      : s1 = s2
      | A, rel, a, p1, p2 =>
        \let
          | P1 : \Pi (a : A) -> \Pi (s1 : acc rel a) -> \Type =>
            \lam (a' : A) =>
                \lam (s1' : acc rel a') =>
                    \Pi (s2' : acc rel a') -> s1' = s2'

          | P2 : \Pi (a : A) -> \Pi (s2 : acc rel a) -> \Type =>
            \lam (a : A) => \lam (s2 : acc rel a) => \Pi (a : A) -> \Pi (h : \Pi (b : A) -> rel b a -> acc rel b) ->
                \Pi (k : \Pi (b : A) -> \Pi (l : rel b a) -> \Pi (s2 : acc rel b) -> h b l = s2) ->
                    \Pi (s2 : acc rel a) -> accREL h = s2

          | P2_term
          : \Pi (a : A) ->
              \Pi (s2 : acc rel a) ->
                  P2 a s2 =>
            \lam (a : A) =>
                \lam (s2 : acc rel a) =>
                    acc.ind
                        P2
                        (\lam (a : A) =>
                            \lam (h2 : \Pi (b : A) -> rel b a -> acc rel b) =>
                                \lam (k2 : \Pi (b : A) -> rel b a -> \Pi (a : A) -> \Pi (h1 : \Pi (b : A) -> rel b a -> acc rel b) ->
                                    (\Pi (b : A) -> \Pi (l : rel b a) -> \Pi (s2 : acc rel b) -> h1 b l = s2) ->
                                    \Pi (s2 : acc rel a) -> accREL h1 = s2) =>
                                    \lam (a : A) =>
                                        \lam (h1 : \Pi (b : A) -> rel b a -> acc rel b) =>
                                            \lam (k1 : \Pi (b : A) -> \Pi (l : rel b a) -> \Pi (s2 : acc rel b) -> h1 b l = s2) =>
                                                \lam (s : acc rel a) => k2 a {?} a h1 k1 s)
                        a
                        s2
        \in
          (acc.ind
              P1
              (P2_term a p2)
              a
              p1)
              p2

    \func wellFounded {A : \Set}
                      (rel : relation A)
      : \Prop =>
      \Pi (x : A) -> acc rel x

    \func downwardsClosed {A : \Set}
                          (rel : relation A)
                          (x y : A)
                          (p : acc (TransitiveClosure.TC rel) y)
                          (r : TransitiveClosure.TC rel x y)
      : acc (TransitiveClosure.TC rel) x
      | rel, x, y, accREL f, r =>
        accREL (\lam z r' => f z (TransitiveClosure.concat rel z x y r' r))

    \func accTransitiveClosure {A : \Set}
                               (rel : relation A)
                               (x : A)
                               (a : acc rel x)
      : acc (TransitiveClosure.TC rel) x
      | rel, x, f => accREL (help rel f)
      \where
        \func help {A : \Set}
                   (rel : relation A)
                   {x : A}
                   (w : acc rel x)
                   (b : A) (rs : TransitiveClosure.TC rel b x)
          : acc (TransitiveClosure.TC rel) b
          | rel, accREL f, b, TransitiveClosure.base r => accTransitiveClosure rel b (f b r)
          | rel, a, b, TransitiveClosure.cons x' t' r' => downwardsClosed rel b x'
                                                                          (help rel a x' r')
                                                                          (TransitiveClosure.base t')

    \func wellFoundedTransitive {A : \Set}
                                (rel : relation A)
                                (w : wellFounded rel)
      : wellFounded (TransitiveClosure.TC rel) =>
      \lam (x : A) => accTransitiveClosure rel x (w x)
  }
}

\module ARS \where {
  \open Relation
  \open Relation.Base
  \open Relation.Utils

  \func rule* {A : \Set}
              (rule : relation A)
    : relation A =>
    ReflexiveTransitiveClosure.reflexiveTransitiveClosure.constructor rule

  \func rule+ {A : \Set}
              (rule : relation A)
    : relation A =>
    TransitiveClosure.transitiveClosure.constructor rule

  -- TODO: revisit spans and rewrite important definitions using them
  --  \func span {A : \Set}
  --             (r : relation A)
  --    : \Type =>
  --    \Sigma (x : A) (y : A) (z : A) (r x y) (r x z)
  --
--  \func cospan {A : \Set}
  --                (r : relation A)
  --    : \Type =>
  --    \Sigma (x : A) (y : A) (z : A) (r y x) (r z x)
  --
--  \func extended-span {A : \Set}
  --                      (r : relation A)
  --    : \Type =>
  --    \Sigma (x : A) (y : A) (z : A) (rule* r x y) (rule* r x z)
  --
--  \func extended-cospan {A : \Set}
  --                         (r : relation A)
  --    : \Type =>
  --    \Sigma (x : A) (y : A) (z : A) (rule* r y x) (rule* r z x)

  \func stronglyNormalizing {A : \Set}
                            (rule : relation A)
    : \Prop =>
    Wellfounded.wellFounded (co-relation rule)

  \func isNormalForm {A : \Set}
                     (rule : relation A)
    : A -> \Prop =>
    \lam (x : A) =>
        Not (\Sigma (y : A)
                    (rule x y))

  \func hasNormalForm {A : \Set}
                      (rule : relation A)
    : A -> \Prop =>
    \lam (x : A) =>
        TruncP (\Sigma (y : A)
                       (rule* rule x y)
                       (isNormalForm rule y))

  \func weaklyNormalizing {A : \Set}
                          (rule : relation A)
    : \Prop =>
    \Pi (x : A) -> hasNormalForm rule x

  \func weaklyConfluent {A : \Set}
                        (rule : relation A)
    : \Prop =>
    \Pi (x y z : A) ->
        \Sigma (rule x y) (rule x z) ->
        TruncP (\Sigma (t : A)
                       (rule* rule y t)
                       (rule* rule z t))

  \func confluent {A : \Set}
                  (rule : relation A) : \Prop =>
    \Pi (x y z : A) ->
        \Sigma (rule* rule x y) (rule* rule x z) ->
        TruncP (\Sigma (t : A)
                       (rule* rule y t)
                       (rule* rule z t))

  \func confluent->weaklyConfluent {A : \Set}
                                   (rule : relation A)
    : confluent rule -> weaklyConfluent rule =>
    \lam (c : confluent rule) =>
        \lam (x y z : A) =>
            \lam (p : \Sigma (rule x y) (rule x z)) =>
                c x y z
                  ((ReflexiveTransitiveClosure.cons y p.1 (ReflexiveTransitiveClosure.base idp)),
                   (ReflexiveTransitiveClosure.cons z p.2 (ReflexiveTransitiveClosure.base idp)))

  \func stronglyNormalizing&&weaklyConfluent->confluent {A : \Set} (rule : relation A)
                                                        (pr1 : stronglyNormalizing rule)
                                                        (pr2 : weaklyConfluent rule)
    : confluent rule => _help1 rule (Wellfounded.wellFoundedTransitive (co-relation rule) pr1) pr2
    \where {
      \func _help1 {A : \Set}
                   (rule : relation A)
                   (pr1 : Wellfounded.wellFounded (rule+ (co-relation rule)))
                   (pr2 : weaklyConfluent rule)
        : confluent rule =>
        \lam x y z span => _help2 rule x y z (pr1 x) pr2 span.1 span.2

      \func _help2 {A : \Set}
                   (rule : relation A)
                   (x y z : A)
                   (pr1 : Wellfounded.acc (rule+ (co-relation rule)) x)
                   (pr2 : weaklyConfluent rule)
                   (r1 : ReflexiveTransitiveClosure.RTC rule x y)
                   (r2 : ReflexiveTransitiveClosure.RTC rule x z)
        : TruncP (\Sigma (t : A)
                         (ReflexiveTransitiveClosure.RTC rule y t)
                         (ReflexiveTransitiveClosure.RTC rule z t))
        | rule, x, y, z, pr1, pr2, ReflexiveTransitiveClosure.base r, ReflexiveTransitiveClosure.base r1 =>
          inP (x, ReflexiveTransitiveClosure.base (inv r), ReflexiveTransitiveClosure.base (inv r1))
        | rule, x, y, z, Wellfounded.accREL f, pr2, ReflexiveTransitiveClosure.base r, r1 =>
          inP (z, transport (\lam v => ReflexiveTransitiveClosure.RTC rule v z) r r1, ReflexiveTransitiveClosure.base idp)
        | rule, x, y, z, Wellfounded.accREL f, pr2, r, ReflexiveTransitiveClosure.base r1 =>
          inP (y, ReflexiveTransitiveClosure.base idp, transport (\lam v => ReflexiveTransitiveClosure.RTC rule v y) r1 r)
        | rule, x, y, z, Wellfounded.accREL f, pr2, ReflexiveTransitiveClosure.cons x1 t1 r1, ReflexiveTransitiveClosure.cons x2 t2 r2 =>
          \let
            | wcrProp => pr2 x x1 x2 (t1, t2)
          \in \scase wcrProp \with {
            | inP wcr =>
              \let
                | innerPoint => wcr.1
                | lSide => wcr.2
                | rSide => wcr.3
                | ind1Prop => _help2 rule x1 y innerPoint (f x1 (TransitiveClosure.base (op t1))) pr2 r1 lSide
              \in \scase ind1Prop \with {
                | inP ind1 =>
                  \let
                    | innerPoint' => ind1.1
                    | lSide' => ind1.2
                    | rSide' => ind1.3
                    | ind2Prop => _help2 rule x2 innerPoint' z (f x2 (TransitiveClosure.base (op t2))) pr2 (ReflexiveTransitiveClosure.concat rule x2 innerPoint innerPoint' rSide rSide') r2
                  \in \scase ind2Prop \with {
                    | inP ind2 => inP (ind2.1, ReflexiveTransitiveClosure.concat rule y innerPoint' ind2.1 lSide' ind2.2, ind2.3)
                  }
              }
          }
    }
}

\module TRS \where {
  -- TODO
}