\import Function
\import Logic
\import Paths
\import Data.Sigma

\module Relation \where {
  \func REL (A : \Set) : \Type => A -> A -> \Prop

  \func isRefl {A : \Set} (r : REL A) : \Prop =>
    \Pi (x : A) -> r x x

  \func isSymm {A : \Set} (r : REL A) : \Prop =>
    \Pi (x y : A) -> r x y -> r y x

  \func isTrans {A : \Set} (r : REL A) : \Prop =>
    \Pi (x y z : A) -> r x y -> r y z -> r x z

  \func flip {A : \Set} (r : REL A) : REL A =>
    \lam (x y : A) => r y x

  \func implies {A : \Set} (r : REL A) (p : REL A) : \Prop =>
    \Pi (x y : A) -> r x y -> p x y

  \func union {A : \Set} (rel1 : REL A)
              (rel2 : REL A) : REL A =>
    \lam (x y : A) => rel1 x y || rel2 x y

  \func idREL {A : \Set} : REL A => \lam (x y : A) => x = y

  \func closure {A : \Set}
                (initRel : REL A)
                (prop : REL A -> \Prop)
                (build : REL A -> REL A) : \Type =>
    \Sigma (newRel : REL A)
           (prop newRel)
           (p : newRel = build initRel)
           (\Pi (p : REL A) ->
               implies initRel p ->
               prop p ->
               implies newRel p)

  \func reflClosure {A : \Set} (rel : REL A)
    : closure rel isRefl _buildReflClosure =>
    (_buildReflClosure rel,
     \lam _ => byRight idp,
     idp,
     \lam (p : REL A) =>
         \lam (o : implies rel p) =>
             \lam (proof : isRefl p) =>
                 \lam x y =>
                     \lam q => \case q \with {
                       | byLeft (t1 : rel x y) => o x y t1
                       | byRight (t2 : x = y) => coe2 (@ (pmap2 p idp t2))
                                                      left
                                                      (proof x)
                                                      right
                     })
    \where
      \func _buildReflClosure {A : \Set} (r : REL A) : REL A => union r idREL

  \func symmClosure {A : \Set} (rel : REL A)
    : closure rel isSymm _buildSymmClosure =>
    (_buildSymmClosure rel,
     \lam (x y : A) => ||.rec Path.inProp
                              byRight
                              byLeft,
     idp,
     \lam (p : REL A) =>
         \lam (o : implies rel p) =>
             \lam (proof : isSymm p) =>
                 \lam x y =>
                     \lam q => \case q \with {
                       | byLeft (t1 : rel x y) => o x y t1
                       | byRight (t2 : rel y x) => proof y x (o y x t2)
                     })
    \where
      \func _buildSymmClosure {A : \Set} (r : REL A) : REL A =>
        union r (flip r)

  -- Lemma 10.3.2 smh is proved by Arend (accessibility is a mere property)

  \data acc {A : \Set} (rel : REL A) (a : A) : \Prop
    | accREL (f : \Pi (b : A) -> (rel b a) -> acc rel b)
    \where
      \func ind {A : \Set} (rel : REL A) (a : A)
                (P : \Pi (a : A) -> (acc rel a -> \Type))
                (f : \Pi (a : A) ->
                    \Pi (h : \Pi (b : A) -> (rel b a) -> acc rel b) ->
                        (\Pi (b : A) -> \Pi (l : rel b a) -> P b (h b l)) ->
                        P a (accREL h : acc rel a))
                (b : A)
                (c : acc rel b)
        : P b c
        | rel', _, P', f', b', (accREL h') =>
          f' b' h' (\lam b => \lam l => ind rel' b' P' f' b (h' b l))

  \func wellFounded {A : \Set} (rel : REL A) : \Prop =>
    \Pi (x : A) -> acc rel x

  \truncated \data TransClosure {A : \Set} (rel : REL A) (a b : A) : \Prop
    | base (r : rel a b)
    | trans (x : A) (t : (TransClosure rel) a x) (r : (TransClosure rel) x b)
    \where
      \func downwardsClosed {A : \Set}
                            (rel : REL A)
                            (x y : A)
                            (a : acc (TransClosure rel) y)
                            (t : TransClosure rel x y)
        : acc (TransClosure rel) x
        | rel, x, y, (accREL h), r =>
          accREL (\lam z =>
              \lam t =>
                  accREL (\lam b =>
                      \lam (p : TransClosure rel b z) =>
                          h b (trans x (trans z p t) r)))

  \func transClosure {A : \Set} (rel : REL A)
    : closure rel isTrans _buildTransClosure =>
    (_buildTransClosure rel,
     \lam x y z => \lam r => \lam q => trans y r q,
     idp,
     \lam (p : REL A) =>
         \lam (i1 : implies rel p) =>
             \lam (transPr : isTrans p) =>
                 \lam (x y : A) =>
                     \lam (t : TransClosure rel x y) =>
                         _implies rel p i1 transPr x y t)
    \where {
      \func _buildTransClosure {A : \Set} (r : REL A) : REL A => TransClosure r

      \func _implies {A : \Set}
                     (rel : REL A)
                     (p : REL A)
                     (i1 : implies rel p)
                     (transPr : isTrans p)
                     (x y : A)
                     (t : TransClosure rel x y) : p x y
        | rel, p, i1, transPr, x, y, base r => i1 x y r
        | rel, p, i1, transPr, x, y, trans x1 t1 r1 =>
          transPr x x1 y
                  (_implies rel p i1 transPr x x1 t1)
                  (_implies rel p i1 transPr x1 y r1)
    }

  \func transReflClosure {A : \Set} (rel : REL A)
    : closure rel
              (\lam (r : REL A) => (isTrans r && isRefl r))
              _buildTransReflClosure =>
    (_buildTransReflClosure rel,
     prod (_isTrans rel) (_isRefl rel),
     idp,
     \lam (p : REL A) =>
         \lam (i1 : implies rel p) =>
             \lam (pr : isTrans p && isRefl p) => _implies rel p i1 pr)
    \where {
      \func _buildTransReflClosure {A : \Set} (r : REL A) : REL A =>
        (reflClosure (TransClosure r)).1

      \func _isTrans {A : \Set} (r : REL A) (x y z : A)
                     (p : TransClosure r x y || (x = y))
                     (t : TransClosure r y z || (y = z))
        : TransClosure r x z || (x = z)
        | r, a, b, c, byRight b1, byRight b2 => byRight
            (b1 *> b2)
        | r, a, b, c, byLeft b1, byRight b2 => byLeft
            (transport (\lam v => TransClosure r a v) b2 b1)
        | r, a, b, c, byRight b1, byLeft b2 => byLeft
            (transport (\lam v => TransClosure r v c) (inv b1) b2)
        | r, a, b, c, byLeft b1, byLeft b2 => byLeft
            (trans b b1 b2)

      \func _isRefl {A : \Set} (r : REL A)
        : \Pi (x : A) -> (_buildTransReflClosure r) x x =>
        \lam (a : A) => byRight idp

      \func _implies {A : \Set}
                     (rel : REL A)
                     (p : REL A)
                     (i1 : implies rel p)
                     (pr : isTrans p && isRefl p)
                     (x y : A)
                     (t : (reflClosure (TransClosure rel)).1 x y) : p x y
        | rel, p, i1, prod a b, x, y, byLeft a1 => \case a1 \with {
          | base r' => i1 x y r'
          | trans x' t' r' => a x x' y
                                (transClosure._implies rel p i1 a x x' t')
                                (transClosure._implies rel p i1 a x' y r')
        }
        | rel, p, i1, prod a b, x, y, byRight b1 => coe2
            (@ (pmap2 p idp b1))
            left
            (b x)
            right
    }

  \func transReflSymmClosure {A : \Set} (rel : REL A)
    : closure rel
              (\lam (r : REL A) => ((isTrans r && isRefl r) && isSymm r))
              _buildTransReflSymmClosure =>
    (_buildTransReflSymmClosure rel,
     prod (prod (_isTrans rel) (_isRefl rel)) (_isSymm rel),
     idp,
     \lam (p : REL A) =>
         \lam (i1 : implies rel p) =>
             \lam (pr : (isTrans p && isRefl p) && isSymm p) => _implies rel p i1 pr)
    \where {
      \func _buildTransReflSymmClosure {A : \Set} (r : REL A) : REL A =>
        (reflClosure (symmClosure (transClosure r).1).1).1

      \func _isTrans {A : \Set} (r : REL A)
        : \Pi (x y z : A) ->
          (_buildTransReflSymmClosure r) x y ->
          (_buildTransReflSymmClosure r) y z ->
          (_buildTransReflSymmClosure r) x z =>
        \lam (x y z : A) =>
            \lam (p1 : (TransClosure r x y || TransClosure r y x) || (x = y)) =>
                \lam (p2 : (TransClosure r y z || TransClosure r z y) || (y = z)) =>
                    \case p1, p2 \with {
                      | byLeft a1, byLeft a2 => \case a1, a2 \with {
                        | byLeft a1', byLeft a2' => (byLeft o byLeft) (trans y a1' a2')
                        | byLeft a1', byRight b2' => {?} -- TODO
                        | byRight b1', byLeft a2' => {?} -- TODO
                        | byRight b1', byRight b2' => (byLeft o byRight) (trans y b2' b1')
                      }
                      | byLeft a1, byRight b2 => \case a1 \with {
                        | byLeft a'' => (byLeft o byLeft) (transport (\lam v => TransClosure r x v) b2 a'')
                        | byRight b'' => (byLeft o byRight) (transport (\lam v => TransClosure r v x) b2 b'')
                      }
                      | byRight b1, byLeft a2 => \case a2 \with {
                        | byLeft a'' => (byLeft o byLeft) (transport (\lam v => TransClosure r v z) (inv b1) a'')
                        | byRight b'' => (byLeft o byRight) (transport (\lam v => TransClosure r z v) (inv b1) b'')
                      }
                      | byRight b1, byRight b2 => byRight (b1 *> b2)
                    }

      \func _isRefl {A : \Set} (r : REL A)
        : \Pi (x : A) ->
          (_buildTransReflSymmClosure r) x x =>
        \lam (x : A) => byRight idp

      \func _isSymm {A : \Set} (r : REL A)
        : \Pi (x y : A) ->
          (_buildTransReflSymmClosure r) x y ->
          (_buildTransReflSymmClosure r) y x =>
        \lam (x y : A) =>
            \lam (p : (TransClosure r x y || TransClosure r y x) || (x = y)) => \case p \with {
              | byLeft a => \case a \with {
                | byLeft a' => (byLeft o byRight) a'
                | byRight b' => (byLeft o byLeft) b'
              }
              | byRight b => byRight (inv b)
            }

      \func _implies{A : \Set}
                    (rel : REL A)
                    (p : REL A)
                    (i1 : implies rel p)
                    (pr : (isTrans p && isRefl p) && isSymm p)
                    (x y : A)
                    (t : (_buildTransReflSymmClosure rel) x y)
        : p x y
        | rel, p, i1, prod (prod p1 p2) p3, x, y, byLeft a => \case a \with {
          | byLeft a1 => \case a1 \with {
            | base r' => i1 x y r'
            | trans x' t' r' => p1 x x' y
                                   (transClosure._implies rel p i1 p1 x x' t')
                                   (transClosure._implies rel p i1 p1 x' y r')
          }
          | byRight b1 => \case b1 \with {
            | base r' => p3 y x (i1 y x r')
            | trans x' t' r' => p3 y x (p1 y x' x
                                           (transClosure._implies rel p i1 p1 y x' t')
                                           (transClosure._implies rel p i1 p1 x' x r'))
          }
        }
        | rel, p, i1, prod (prod p1 p2) p3, x, y, byRight b => coe2
            (@ (pmap2 p idp b))
            left
            (p2 x)
            right
    }
}

\module ARS \where {
  \open Relation

  \func stronglyNormalizing {A : \Set} (rule : REL A) : \Prop =>
    wellFounded rule

  \func isNormalForm {A : \Set} (rule : REL A)
    : A -> \Prop => \lam (x : A) => Not (\Sigma (y : A) (rule x y))

  \func hasNormalForm {A : \Set} (rule : REL A) : A -> \Prop =>
    \lam (x : A) =>
        \let | rule* : REL A => (transReflClosure rule).1
        \in TruncP (\Sigma (y : A) (rule* x y) (isNormalForm rule y))

  \func weaklyNormalizing {A : \Set} (rule : REL A) : \Prop =>
    \Pi (x : A) -> hasNormalForm rule x

  \func weaklyConfluent {A : \Set} (rule : REL A) : \Prop =>
    \let | rule* : REL A => (transReflClosure rule).1
    \in \Pi (x : A) ->
        TruncP (\Pi (y z : A) ->
            \Sigma (rule x y) (rule x z) ->
            \Sigma (t : A) (rule* y t) (rule* z t))

  \func confluent {A : \Set} (rule : REL A) : \Prop =>
    \let | rule* : REL A => (transReflClosure rule).1
    \in \Pi (x : A) ->
        TruncP (\Pi (y z : A) ->
            \Sigma (rule* x y) (rule* x z) ->
            \Sigma (t : A) (rule* y t) (rule* z t))

  \func confluent->weaklyConfluent {A : \Set} (rule : REL A)
    : confluent rule -> weaklyConfluent rule =>
    \lam (c : confluent rule) =>
        \lam (x : A) =>
            inP (\lam (y z : A) =>
                \lam (p : \Sigma (rule x y) (rule x z)) => _help2 A rule x y z (c x) p)
    \where {
      \func rule* {A : \Set} (rule : REL A) : REL A => (transReflClosure rule).1

      \func _help1 {A : \Type}
                   {B C D : A -> \Type}
                   (f : \Pi (a : A) -> (C a) -> (D a))
                   (p : \Sigma (a : A) (B a) (C a))
        : \Sigma (a : A) (B a) (D a) \elim p
        | (a, b, c) => (a, b, f a c)

      \sfunc _help2
        (A : \Set)
        (rule : REL A)
        (x y z : A)
        (t : TruncP (\Pi (y z : A) ->
            \Sigma (rule* rule x y) (rule* rule x z) ->
            \Sigma (t : A) (rule* rule y t) (rule* rule z t)))
        (p : \Sigma (rule x y) (rule x z))
        : \Sigma (t : A) (rule* rule y t) (rule* rule z t)
        | A, rule, x, y, z, inP a, p => a y z (tupleMap (byLeft o base) (byLeft o base) p)
        | A, rule, x, y, z, truncP a a' i, p => _help2 A rule x y z a p
    }

  \func stronglyNormalizing&&weaklyConfluent->confluent {A : \Set} (rule : REL A)
                                                        (pr1 : stronglyNormalizing rule)
                                                        (pr2 : weaklyConfluent rule)
    : confluent rule =>
    _help1 A rule pr1 pr2
    \where {
      \func _help1 (A : \Set) (rule : REL A)
                   (pr1 : stronglyNormalizing rule)
                   (pr2 : weaklyConfluent rule) : confluent rule
        | A, rule, p1, p2 => \lam (x : A) =>
            inP (\lam (y z : A) =>
                \lam (t1 : \Sigma (TransClosure rule x y || (x = y)) (TransClosure rule x z || (x = z))) => {?})

      -- stronglyNormalizing {A} rule === wellFounded rule === \Pi (x : A) -> acc rule x
      -- accREL (f : \Pi (b : A) -> (rel b a) -> acc rel b)
      -- {A : \Set} (rel : REL A) (a : A)
      --                (P : \Pi (a : A) -> (acc rel a -> \Type))
      --                (f : \Pi (a : A) ->
      --                    \Pi (h : \Pi (b : A) -> (rel b a) -> acc rel b) ->
      --                        (\Pi (b : A) -> \Pi (l : rel b a) -> P b (h b l)) ->
      --                        P a (accREL h : acc rel a))
      --                (b : A)
      --                (c : acc rel b)
      --        : P b c
      -- confluent {A} rule === \Pi (x : A) ->
      --        TruncP (\Pi (y z : A) ->
      --            \Sigma (rule* x y) (rule* x z) ->
      --            \Sigma (t : A) (rule* y t) (rule* z t))
    }
}