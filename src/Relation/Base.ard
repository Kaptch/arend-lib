\import Function
\import Logic
\import Paths

\module Relation \where {
  \func REL (A : \Set) : \Type => A -> A -> \Prop

  \func isRefl {A : \Set} (r : REL A) : \Prop =>
    \Pi (x : A) -> r x x

  \func isSymm {A : \Set} (r : REL A) : \Prop =>
    \Pi (x y : A) -> r x y -> r y x

  \func isTrans {A : \Set} (r : REL A) : \Prop =>
    \Pi (x y z : A) -> r x y -> r y z -> r x z

  \func flip {A : \Set} (r : REL A) : REL A =>
    \lam (x y : A) => r y x

  \func implies {A : \Set} (r : REL A) (p : REL A) : \Prop =>
    \Pi (x y : A) -> r x y -> p x y

  \func union {A : \Set} (rel1 : REL A)
              (rel2 : REL A) : REL A =>
    \lam (x y : A) => rel1 x y || rel2 x y

  \func idREL {A : \Set} : REL A => \lam (x y : A) => x = y

  \func closure {A : \Set}
                (initRel : REL A)
                (prop : REL A -> \Prop)
                (build : REL A -> REL A) : \Type =>
    \Sigma (newRel : REL A)
           (prop newRel)
           (p : newRel = build initRel)
           (\Pi (p : REL A) ->
               implies initRel p ->
               prop p ->
               implies newRel p)

  \func reflClosure {A : \Set} (rel : REL A)
    : closure rel isRefl _buildReflClosure =>
    (_buildReflClosure rel,
     \lam _ => byRight idp,
     idp,
     \lam (p : REL A) =>
         \lam (o : implies rel p) =>
             \lam (proof : isRefl p) =>
                 \lam x y =>
                     \lam q => \case q \with {
                       | byLeft (t1 : rel x y) => o x y t1
                       | byRight (t2 : x = y) => coe2 (@ (pmap2 p idp t2))
                                                      left
                                                      (proof x)
                                                      right
                     })
    \where
      \func _buildReflClosure {A : \Set} (r : REL A) : REL A => union r idREL

  \func symmClosure {A : \Set} (rel : REL A)
    : closure rel isSymm _buildSymmClosure =>
    (_buildSymmClosure rel,
     \lam (x y : A) => ||.rec Path.inProp
                              byRight
                              byLeft,
     idp,
     \lam (p : REL A) =>
         \lam (o : implies rel p) =>
             \lam (proof : isSymm p) =>
                 \lam x y =>
                     \lam q => \case q \with {
                       | byLeft (t1 : rel x y) => o x y t1
                       | byRight (t2 : rel y x) => proof y x (o y x t2)
                     })
    \where
      \func _buildSymmClosure {A : \Set} (r : REL A) : REL A =>
        union r (flip r)

  -- Lemma 10.3.2 smh is proved by Arend (accessibility is a mere property)

  \data acc {A : \Set} (rel : REL A) (a : A) : \Prop
    | accREL (f : \Pi (b : A) -> (rel b a) -> acc rel b)
    \where
      \func ind {A : \Set} (rel : REL A) (a : A)
                (P : \Pi (a : A) -> (acc rel a -> \Type))
                (f : \Pi (a : A) ->
                    \Pi (h : \Pi (b : A) -> (rel b a) -> acc rel b) ->
                        (\Pi (b : A) -> \Pi (l : rel b a) -> P b (h b l)) ->
                        P a (accREL h : acc rel a))
                (b : A)
                (c : acc rel b)
        : P b c
        | rel', _, P', f', b', (accREL h') =>
          f' b' h' (\lam b => \lam l => ind rel' b' P' f' b (h' b l))

  \func wellFounded {A : \Set} (rel : REL A) : \Prop =>
    \Pi (x : A) -> acc rel x

  \truncated \data TransClosure {A : \Set} (rel : REL A) (a b : A) : \Prop
    | base (r : rel a b)
    | trans (x : A) (t : (TransClosure rel) a x) (r : (TransClosure rel) x b)
    \where
      \func downwardsClosed {A : \Set}
                            (rel : REL A)
                            (x y : A)
                            (a : acc (TransClosure rel) y)
                            (t : TransClosure rel x y)
        : acc (TransClosure rel) x
        | rel, x, y, (accREL h), r =>
          accREL (\lam z =>
              \lam t =>
                  accREL (\lam b =>
                      \lam (p : TransClosure rel b z) =>
                          h b (trans x (trans z p t) r)))

  \func transClosure {A : \Set} (rel : REL A)
    : closure rel isTrans _buildTransClosure =>
    (_buildTransClosure rel,
     \lam x y z => \lam r => \lam q => trans y r q,
     idp,
     \lam (p : REL A) =>
         \lam (i1 : implies rel p) =>
             \lam (transPr : isTrans p) =>
                 \lam (x y : A) =>
                     \lam (t : TransClosure rel x y) =>
                         _implies rel p i1 transPr x y t)
    \where {
      \func _buildTransClosure {A : \Set} (r : REL A) : REL A => TransClosure r

      \func _implies {A : \Set}
                     (rel : REL A)
                     (p : REL A)
                     (i1 : implies rel p)
                     (transPr : isTrans p)
                     (x y : A)
                     (t : TransClosure rel x y) : p x y
        | rel, p, i1, transPr, x, y, base r => i1 x y r
        | rel, p, i1, transPr, x, y, trans x1 t1 r1 =>
          transPr x x1 y
                  (_implies rel p i1 transPr x x1 t1)
                  (_implies rel p i1 transPr x1 y r1)
    }

  \func transReflClosure {A : \Set} (rel : REL A)
    : closure rel
              (\lam (r : REL A) => (isTrans r && isRefl r))
              _buildTransReflClosure =>
    (_buildTransReflClosure rel,
     prod (_isTrans rel) (_isRefl rel),
     idp,
     \lam (p : REL A) =>
         \lam (i1 : implies rel p) =>
             \lam (pr : isTrans p && isRefl p) => _implies rel p i1 pr)
    \where {
      \func _buildTransReflClosure {A : \Set} (r : REL A) : REL A =>
        (reflClosure (TransClosure r)).1

      \func _isTrans {A : \Set} (r : REL A) (x y z : A)
                     (p : TransClosure r x y || (x = y))
                     (t : TransClosure r y z || (y = z))
        : TransClosure r x z || (x = z)
        | r, a, b, c, byRight b1, byRight b2 => byRight
            (b1 *> b2)
        | r, a, b, c, byLeft b1, byRight b2 => byLeft
            (transport (\lam v => TransClosure r a v) b2 b1)
        | r, a, b, c, byRight b1, byLeft b2 => byLeft
            (transport (\lam v => TransClosure r v c) (inv b1) b2)
        | r, a, b, c, byLeft b1, byLeft b2 => byLeft
            (trans b b1 b2)

      \func _isRefl {A : \Set} (r : REL A)
        : \Pi (x : A) -> (_buildTransReflClosure r) x x =>
        \lam (a : A) => byRight idp

      \func _implies {A : \Set}
                     (rel : REL A)
                     (p : REL A)
                     (i1 : implies rel p)
                     (pr : isTrans p && isRefl p)
                     (x y : A)
                     (t : (reflClosure (TransClosure rel)).1 x y) : p x y
        | rel, p, i1, prod a b, x, y, byLeft a1 => \case a1 \with {
          | base r' => i1 x y r'
          | trans x' t' r' => a x x' y
                                (transClosure._implies rel p i1 a x x' t')
                                (transClosure._implies rel p i1 a x' y r')
        }
        | rel, p, i1, prod a b, x, y, byRight b1 => coe2
            (@ (pmap2 p idp b1))
            left
            (b x)
            right
    }
}

\module ARS \where {
  \open Relation

  \func stronglyNormalizing {A : \Set} (rule : REL A) : \Prop =>
    wellFounded rule

  \func isNormalForm {A : \Set} (rule : REL A)
    : A -> \Prop => \lam (x : A) => Not (\Sigma (y : A) (rule x y))

  \func hasNormalForm {A : \Set} (rule : REL A) : A -> \Prop =>
    \lam (x : A) =>
        \let | rule* : REL A => (transReflClosure rule).1
        \in TruncP (\Sigma (y : A) (rule* x y) (isNormalForm rule y))

  \func weaklyNormalizing {A : \Set} (rule : REL A) : \Prop =>
    \Pi (x : A) -> hasNormalForm rule x

  \func weaklyConfluent {A : \Set} (rule : REL A) : \Prop =>
    \let | rule* : REL A => (transReflClosure rule).1
    \in \Pi (x : A) ->
        TruncP (\Pi (y z : A) ->
            \Sigma (rule x y) (rule x z) ->
            \Sigma (t : A) (rule* y t) (rule* z t))

  \func confluent {A : \Set} (rule : REL A) : \Prop =>
    \let | rule* : REL A => (transReflClosure rule).1
    \in \Pi (x : A) ->
        TruncP (\Pi (y z : A) ->
            \Sigma (rule x y) (rule x z) ->
            \Sigma (t : A) (rule* y t) ((rule z t || (z = t))))

  \func confluent->weaklyConfluent {A : \Set} (rule : REL A)
    : confluent rule -> weaklyConfluent rule =>
    \lam (c : confluent rule) =>
        \lam (x : A) =>
            inP (\lam (y z : A) =>
                \lam (p : \Sigma (rule x y) (rule x z)) => _help2 A rule x y z (c x) p)
    \where {
      \func _help1 {A : \Type}
                   {B C D : A -> \Type}
                   (f : \Pi (a : A) -> (C a) -> (D a))
                   (p : \Sigma (a : A) (B a) (C a))
        : \Sigma (a : A) (B a) (D a) \elim p
        | (a, b, c) => (a, b, f a c)

      \sfunc _help2
        (A : \Set)
        (rule : REL A)
        (x y z : A)
        (t : TruncP (\Pi (y z : A) ->
            \Sigma (rule x y) (rule x z) ->
            \Sigma (t : A) ((transReflClosure rule).1 y t) ((rule z t || (z = t)))))
        (p : \Sigma (rule x y) (rule x z))
        : \Sigma (t : A) ((transReflClosure rule).1 y t) ((transReflClosure rule).1 z t)
        | A, rule, x, y, z, inP a, p => _help1 {A}
                                               {\lam t => TransClosure rule y t || (y = t)}
                                               {\lam t => rule z t || (z = t)}
                                               {\lam t => TransClosure rule z t || (z = t)}
                                               (\lam (t : A) => \lam u => ||.map base id u)
                                               (a y z p)
        | A, rule, x, y, z, truncP a a' i, p => _help2 A rule x y z a p
    }
}